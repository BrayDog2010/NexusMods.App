QA Process

1. Ticket Requirements (Applies to All Tickets)
Definitions of Done (DoD) must be included in every ticket.
Clear acceptance criteria.
Expected behavior.
Design references (if applicable).
Smaller Fixes:
Clearly outline how the fix should behave.
DoD focused on specific outputs/results.
Complex Features:
Require detailed design documents and behavior specifications.
Extensive DoD, including success criteria for each component.
Additional documentation for edge cases, user flows, and dependencies.

2. Testing Approach
A. Iteration Testing
Focus on smaller tickets:
Test individual components or fixes as they are developed.
Validate against the DoD and expected behavior.
Perform regression testing to ensure no impact on existing features.
B. Full QA for Larger Features (Feature Complete Testing)
Once all smaller tickets are completed for a larger feature:
Execute a Full QA Process:
End-to-end testing of the entire feature.
Validate all integrated parts function together correctly.
Test across relevant platforms, environments, or user roles.
Perform usability and edge case testing.
Ensure feature meets overall DoD for the project/epic.
Sign-off required before release.

Design Process

1. Initial Design Review
Conduct a high-level, quick review of major limitations that could impact designs.
Participants: Tim, Laurence, and relevant stakeholders.
Purpose: Identify and address potential blockers early on.

2. Design Creation
Start the design process and create Figma designs.
Track design items in GitHub using a separate board for design.
Use labels to categorize design items and indicate readiness for development.

3. Technical Design Review
Review designs with the developers responsible for implementation.
Ensure technical feasibility and identify potential challenges.

4. Design Approval
All design items require Laurence’s review before implementation.
Designs do not proceed to development until approved by Laurence.

5. Development Handoff
Label design items in GitHub to indicate readiness for developers to start work.
Developers begin implementation based on approved designs.

6. QA and Design Validation
Upon feature completion, send the implementation to QA.
QA checks both functionality and design consistency.

7. Handling Multi-Sprint Items
Ideally, items should not span multiple sprints due to prior refinement.
Break down tickets into smaller components that align with team structure.

8. Communicating Work in Progress
Make work-in-progress items visible within the app.
Use feature flags to control visibility and avoid exposing incomplete features to users.

Ceremonies and Processes in the App Team

Daily Standups
Standups take place every day at 2:30 PM.
Team members quickly share updates on what they worked on yesterday and their plans for today.
After the standup, time is allocated for discussing any challenges or blockers.
Also an opportunity for leadership to get an understanding of the current velocity of the team by comparing ticket progress with the sprint’s progress.

Sprint Kickoff
Held at the start of each sprint to align the team on priorities and objectives.

Sprint Retrospective
Conducted at the end of each sprint to reflect on what went well, what didn’t, and areas for improvement.
Team members also take the opportunity to acknowledge and appreciate each other’s contributions.

Backlog Refinement
Occurs midway through the sprint to review new issues, discuss estimates and priorities, and refine backlog items.

Sprint Planning
The project team lead and product manager meet the day before the retrospective to determine priorities for the next sprint.





