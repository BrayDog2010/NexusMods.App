using DynamicData;
using NexusMods.Abstractions.GameLocators;
using NexusMods.App.UI.Controls;
using NexusMods.MnemonicDB.Abstractions;
using NexusMods.Paths;
namespace NexusMods.App.UI.Helpers.TreeDataGrid.New.FolderGenerator;

/// <summary>
/// A class responsible for creating 'folders' where we have views of files in a tree
/// using <see cref="CompositeItemModel{TKey}"/>. Each instance is tied with a <see cref="LocationId"/>
/// such as <see cref="LocationId.Game"/>, <see cref="LocationId.Saves"/> etc.
/// </summary>
public class TreeFolderGeneratorForLocationId<TTreeItemWithPath> where TTreeItemWithPath : ITreeItemWithPath
{
    /// <example>
    /// Represents all files at the 'root' of this <see cref="LocationId"/>
    /// </example>
    private readonly GeneratedFolder<TTreeItemWithPath> _rootFolder = new();
    
    /// <summary>
    /// Obtains an observable set of <see cref="CompositeItemModel{TKey}"/> for the specified folder.
    /// </summary>
    public CompositeItemModel<EntityId> ModelForRoot()
    {
        return _rootFolder.Model;
    }
    
    /// <summary>
    /// Invoked on every file received from the caller.
    /// This adds the file to the inner tree.
    /// </summary>
    /// <param name="path">The relative path of the item (file) that was just read in.</param>
    /// <param name="itemModel">The <see cref="CompositeItemModel{TKey}"/> (tree node) for the file.</param>
    internal void OnReceiveFile(RelativePath path, CompositeItemModel<EntityId> itemModel)
    {
        var folderPath = path.Parent;
        var folder = GetOrCreateFolder(folderPath, out _, out _);
        folder.AddFileItemModel(itemModel);
    }
    
    /// <summary>
    /// Invoked on every file deleted from the caller.
    /// This removes the file from the inner tree.
    /// </summary>
    /// <param name="path">The relative path of the item (file) to be removed.</param>
    /// <param name="itemModel">The <see cref="CompositeItemModel{TKey}"/> (tree node) for the file.</param>
    /// <returns>True if the root folder for this LocationId is now empty.</returns>
    internal bool OnDeleteFile(RelativePath path, CompositeItemModel<EntityId> itemModel)
    {
        var folder = GetOrCreateFolder(path.Parent, out var parentFolder, out var parentFolderName);
        var deleteFolder = folder.DeleteFileItemModel(itemModel.Key);
        if (deleteFolder)
            parentFolder.DeleteSubfolder(parentFolderName);

        return deleteFolder; 
    }

    /// <summary>
    /// Obtains the folder by navigating through the <see cref="_rootFolder"/> down
    /// to the specified folder. If the folder does not exist, it will be created.
    /// </summary>
    /// <param name="path">The path of the folder to obtain.</param>
    /// <param name="parentFolder">The parent of the folder returned.</param>
    /// <param name="parentFolderName">Name of the parent folder.</param>
    internal GeneratedFolder<TTreeItemWithPath> GetOrCreateFolder(RelativePath path, out GeneratedFolder<TTreeItemWithPath> parentFolder, out RelativePath parentFolderName)
    {
        // Go through all parents of the path, and create them if they don't exist.
        parentFolder = _rootFolder;
        parentFolderName = "";
        
        var currentFolder = _rootFolder;
        foreach (var part in path.GetParts())
        {
            parentFolder = currentFolder;
            currentFolder = currentFolder.GetOrCreateChildFolder(part);
            parentFolderName = part;
        }
        
        return currentFolder;
    }
}

/// <summary>
/// Represents a single folder generated by the <see cref="TreeFolderGeneratorForLocationId{TTreeItemWithPath}"/>
/// </summary>
/// <remarks>
///     Note: Sewer. This should ideally be a struct, but due to limitations with DynamicData's API,
///     we're forced to make this a class.
/// </remarks>
internal class GeneratedFolder<TTreeItemWithPath> where TTreeItemWithPath : ITreeItemWithPath
{
    /// <summary>
    /// The reference count.
    /// </summary>
    public uint RefCount = 0;

    /// <summary>
    /// The <see cref="CompositeItemModel{TKey}"/> representing the current folder node
    /// in the tree visually.
    /// </summary>
    /// <remarks>
    ///     We default to an invalid entity of type <see cref="EntityId.MaxValueNoPartition"/>, as this will need
    ///     to store children (files) which are MnemonicDB entities and thus require it (unlike folders).
    ///
    /// 
    /// </remarks>
    public CompositeItemModel<EntityId> Model = new(EntityId.MaxValueNoPartition);

    /// <summary>
    /// All of the <see cref="CompositeItemModel{TKey}"/>(s) for each file in this folder.
    /// </summary>
    /// <remarks>
    ///     The key is the unique entity ID for the file.
    ///     This powers the <see cref="TreeDataGridItemModel{TModel,TKey}.ChildrenObservable"/> field.
    /// </remarks>
    public SourceCache<CompositeItemModel<EntityId>, EntityId> Files = new(x => x.Key);
    
    /// <summary>
    /// All of the <see cref="CompositeItemModel{TKey}"/>(s) for each folder in this folder.
    /// </summary>
    /// <remarks>The key is the folder name, without any separators.</remarks>
    public SourceCache<GeneratedFolder<TTreeItemWithPath>, RelativePath> Folders = new(_ => null!);
    
    /// <summary/>
    public GeneratedFolder() { }

    /// <summary>
    /// Adds a file <see cref="CompositeItemModel{EntityId}"/> to this folder
    /// </summary>
    /// <param name="child">The child <see cref="CompositeItemModel{EntityId}"/></param>
    public void AddFileItemModel(CompositeItemModel<EntityId> child)
    {
        var alreadyPresent = Files.Lookup(child.Key).HasValue;
        var incrementSize = Convert.ToUInt32(!alreadyPresent);
        Files.AddOrUpdate(child);
        RefCount += incrementSize;
    }

    /// <summary>
    /// Removes a file CompositeItemModel from this folder
    /// </summary>
    /// <param name="key">The <see cref="EntityId"/> of the child to remove.</param>
    /// <returns>True if this folder is empty.</returns>
    public bool DeleteFileItemModel(EntityId key)
    {
        var alreadyPresent = Files.Lookup(key).HasValue;
        if (alreadyPresent)
        {
            Files.Remove(key);
            RefCount -= 1;
        }

        return RefCount == 0;
    }
    
    /// <summary>
    /// Gets or creates a child folder within this <see cref="GeneratedFolder{TTreeItemWithPath}"/>
    /// </summary>
    /// <param name="folderName">
    ///     Name of the (single) folder, for example, 'saves'.
    ///     Should not contain separators or other subfolders.
    /// </param>
    public GeneratedFolder<TTreeItemWithPath> GetOrCreateChildFolder(RelativePath folderName)
    {
        var optionalChild = Folders.Lookup(folderName);
        GeneratedFolder<TTreeItemWithPath>  result;
        if (optionalChild.HasValue)
            result = optionalChild.Value;
        else // create a new folder if not already exists
        {
            result = CreateChildFolder();
            // Note(sewer): No direct API without `Edit` that allows for manually specifying key.
            Folders.Edit(updater => updater.AddOrUpdate(result, folderName));
        }

        return result;
    }

    /// <summary>
    /// Deletes a subfolder with a given name.
    /// </summary>
    /// <param name="folderName">The name of the folder to delete from.</param>
    public void DeleteSubfolder(RelativePath folderName)
    {
        Folders.Remove(folderName);
    }

    private GeneratedFolder<TTreeItemWithPath> CreateChildFolder() => new();
}
